Git course

***
<branch name> - имя ветки
<commit name> - имя коммита (40-значный номер)
<filename> - имя файла
<path> - путь к файлу с указанием самого файла
<message> - заголовок коммита
<search message> или <prompt> - текст запроса для поиска
n, m - подразумевают некоторое числовое значение, либо используются при обозначении диапазона: <some stuff 1>..<some stuff n>

Обычно в командах <branch name> и <commit name> взаимозаменяемые. В заметках они указаны в контексе предоставляемого
в видео примера.
***

2.1 Основы - Конфигурация

	git init - создать репозиторий
	git config user.name / user.email - имя разработчика и email
		--system - системный конфиг, на уровне машины
		--global - глобальный конфиг, на уровне пользователя
		--local - локальный конфиг, на уровне проекта
	git config --list - список параметров
	git config --unset user.name / user.email - удалить
	git config --remove-section - удалить секцию
	git config --global alias.<name>  <command> - сокращение
	git config --global alias.<name> '!git <command 1>;git <command 2>' - несколько комманд

2.2 Основы - Создание репозитория, первый коммит

	git status - проверить статус репозитория
	git add <filename> - добавить файл с изменениями в индекс
	git add . - добавить все изменения в индекс
	git commit - перенести изменения из индекс в репозиторий
	git commit -m - перенести изменения с сообщением
	
2.3 Основы - Git и права на файлы

	100644:
		100 - файл
		644 - неисполнимый
		755 - исполнимый
	git update-index --chmod=+x <filename> - изменить исполняемость файла
	
2.4 Основы - Git show, кто такие автор и коммиттер

	git show --pretty=fuller - подробности коммита
	Автор - тот, кто написал код
	Коммитер - тот, кто закоммитил
	
2.5 Основы - Добавление файлов и директорий, git status

	git не видит пустые директории
	git reset HEAD <filename> - откатить изменения
	
2.6 Основы - Хороший коммит

	atomic - каждый коммит относится к определенной задаче
	consistent - код, отправляемый в репозиторий завершен и работает
	Commit early. Commit often.
	<50 символов в заголовке, <72 символов в каждой строке подробного описания
	
2.7 Основы - Зачем нужен индекс?

	git add -p <filename> - построчно решить что коммитить в репозиторий в файле
	
2.8 Основы - Коммиты без git add

	git commit -am <message> - пропустить add и сразу закомитить(работает только для проиндексированных файлов)
	.gitignore - файл, который определяет какие файлы коммитить не нужно
	git commit <path> - пропустить add и коммитнуть файл
	git add . - добавляет только текующую директорию
	git add -A - добавить всю корневую директорию
	
2.9 Основы - Удаление и переименование файлов

	1) Удалить файл в рабочей дирректории и коммитнуть изменения
	2) git rm <filename> - удалит в гите и раб. директории
	3) git rm --cached <filename> - удалит только в гите
	
	git mv <old filename> <new filename> - переименовать файл
	
3.1 Ветки – Введение

	Тематические ветки - новая функциональность, которую пока не нужно включать в релизную версию
	Релизные ветки - Когда происходит релиз, создается новая ветка для поддержки этого релиза, а в основной ветке продолжается разработка новой версии
	
3.2 Ветки – Создание и переключение

	Первый коммит создает master ветку
	Ветка это ссылка на коммит
	
	Каждый коммит имеет идентификатор
	git branch - Название ветки
	git branch -v - Название ветки и коммит на который она ссылается
	HEAD - указатель на текущую ветку
	
	git branch <branch name> - создать новую ветку (она будет указывать на тот же коммит, на котором находится HEAD)
	git checkout <branch name> - переключиться на ветку
	git checkout -b <branch name> - создать и переключиться на новую ветку
	
3.3 Ветки – Команда checkout при незакоммиченных изменениях

	Если есть изменения, то смена ветки вызовет ошибку.
	git checkout -f <branch name> - сменить ветку потеряв все незакоммиченные изменения
	git stash - заархивировать незакомиченные изменения
	git stash pop - разархивировать данные, архивированные git stash
	При этом с git stash можно переносить изменения с одной ветки на другую.
	Также, если в одной ветке изменения файла повторяют закомиченные изменения второй ветки, то ветку можно будет сменить.
	
	Т.е. если файлы в ветках различаются - ошибка, в другом случае можно менять ветку.
	
	Если добавить изменения в индекс в одной ветке, а потом перейти на другую ветку и выполнить коммит, измененые файлы из одной ветки попадут в другую ветку.
	
3.4 Ветки – Перенос незакоммиченных изменений

	Если изменения не закоммичены, можно создать новую ветку на текущем коммите и коммитнуть туда изменения.
	
3.5 Ветки – Перенос веток "вручную"

	Если изменения уже закоммичены, но должны быть перенесены в другую ветку.
	
	В такой ситуации, создается новая ветка, а старая ветка, где эти изменения быть не должны, должна быть перемещена назад.
	Для этого можно использовать следующее:
	git branch -f <branch name> <commit name>       Перед использованием, нужно перейти на новую созданную ветку
	git checkout -b <branch name> <commit name>     Создать ветку на указанном коммите
	git checkout -B <branch name> <commit name>     Перенести существующую ветку на указанный коммит
	
3.6 Ветки – Состояние отделённой HEAD

	Если с помощью git checkout <commit name> перейти по коммиту, а не по ветке,то HEAD будет находиться в отделенном состоянии.
	Можно продолжать делать коммиты, но они не будут принадлежать какой то ветке. 
	Если переключиться на ветку, то вернутся на созданные коммиты можно только по их названию. При этом гит через некоторое время удалит эти коммиты.
	git cherry-pick <commit name>  -  скопировать коммит на текущую ветку
	
3.7 Ветки – Восстановление предыдущих версий файлов

	git checkout <branch name> <path> - восстановить файл из указанной ветки / коммита.
	Файл будет автоматически добавлен в индекс
	git reset <path> - убрать из индекса
	
3.8 Ветки – Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/

	git log - посмотреть историю коммитов для текущей ветки
	git log --oneline - кратко
	git log <branch name> - для конкретной ветки
	git show <commit name> - показать подробности конкретного коммита
	Чтобы ссылаться на предыдующие версии коммитов, можно использовать ~. HEAD~ - на 1 коммит назад, HEAD~3 - на 3 коммита назад
	@ это HEAD
	git show @~:<filename> - покажет версию указанного файла в этом коммите
	
	git show :/<search message> - найти коммит, где есть данное слово

3.9 Ветки – Слияние веток "перемоткой"

	git merge <branch name> - слияние веток с указанной в текущую.
	Fast-forward - самый простой способ слияния. При этом, указатель текущей ветки перемещается на указанную ветку.
	cat .git/ORIG_HEAD - где был указатель перед merge. Используется, если нужно откатить слияние.
	git branch -f <branch name> ORIG_HEAD - пример использования
	
3.10 Ветки – Удаление веток

	git branch -d <branch name> - удалить ссылку на коммит(т.е. ветку). 
	Однако комманда сработает только если удаляемая ветка объединена с текущей.
	git branch -D <branch name> - все равно удалить ветку (при этом коммиты остануться, т.к. гит удалит их не сразу)
	
3.11 Ветки – История переключений веток: лог ссылок reflog

	git reflog  - рефлог для HEAD
	git reflog <branch name> - рефлог для указанной ветки
	Reflog содержит историю изменения для указателя.
	
	1) Если ветка была удалена давно, но нам нужны коммиты из нее, то по рефлогу можно найти названия этих коммитов.
	На коммиты можно ссылаться как на <branch name>@{<n>} - чтобы вызвать название коммита из рефлога
	
	git log --oneline -g - одно и то же, что и reflog
	
	git reflog --date=<date format> - вывести истоию с датами( формат iso )
	gc.reflogExpire - время хранения рефлогов (90 дней по умолчанию)
	gc.reflogExpireUnreachable - для коммитов без ветки (30 дней по умолчанию)
	
4.1 Удаление "лишних" файлов и незакоммиченных изменений

	git reset --hard - удалить незакоммиченные изменения (не работает на неотслеживаемых файлах)
	git clean -df - удалить незакоммиченные изменения и неотслеживаемые файлы и директории
	git clean -dxf - + удалить те файлы, которые игнорируются гитигнор
	
5.1 Reset – Жесткий reset --hard: отмена изменений, удаление коммитов

	git reset --hard <commit name> - вернуться на указанный коммит при этом передвинув ветку на этот коммит
	Дальнейшая разработка будет идти от текущего коммита, а прошлые будут забыты.
	git reset --hard ORIG_HEAD - вернуться на ранее откатанный коммит
	
5.2 Reset – Мягкий reset --soft: замена и объединение коммитов

	git reset --soft <commit name> - также переносит указатель ветки на указанный коммит, но не трогает рабочую директорию и индекс
	Удобно, если в коммите были ошибки, то можно откатиться, исправить их и снова коммитнуть
	git commit -c <commit name> - взять комментарий из уже существующего коммита
	
5.3 Reset – Правка последнего коммита: commit --amend

	git commit --amend - замена последнего (и текущего) коммита (также полезно чтобы изменить комментарий для коммита)
	
5.4 Reset – Смешанный reset (без флагов), сравнение видов reset

	git reset --mixed - передвигает ветку, сбрасывает индекс, но не трогает рабочую директорию
	git reset HEAD - можно очистить в индекс все изменения, откатившись к текущему коммиту
	git reset <filename> - очистить все изменения в индексе для указанного файла
	git reset <commit name> <filename> - очистить все изменения в индексе для указанного файла до указанного коммита
	
5.5 Reset – Таблица с действиями reset

	git help reset - таблица, описывающая последствия reset для разных видов
	
6.1 Просмотр – Сравнение коммитов, веток и не только: git diff

	git diff <commit name 1> <commit name 2> - показывает различия между двумя коммитами
	git diff <commit name 1>...<commit name 2> - какие конкретно изменения произошли для <commit name 2>
	git diff HEAD - изменения в рабочей директории с момента последнего коммита
	
	git diff игнорирует неотслеживаемые файлы
	
	git diff --cached <commit name> - сравнить проиндексированные изменение, но не закоммиченные с указанным коммитом
	git diff <filename> - для конкретного файла
	git diff <commit name 1> <commit name 2> <filename>
	git diff --name-only <commit name 1> <commit name 2> - только именна различающихся файлов
	
6.2 Просмотр – Вывод истории: git log, форматирование коммитов

	git log - вывести историю коммитов
	git log --oneline - аббревиатура коммита и заголовок коммита
	
	Вывод можно форматировать флагами --pretty=format | --date
	
	git config --global format.pretty <alias name> <format settings>
	git config --global log.date <format settings>
	
6.3 Просмотр – Диапазоны коммитов для git log и не только

	git log <commit name> - вывести лог для коммита
	git log <commit name 1> ... <commit name n> --graph - вывести лог для нескольких коммитов
	git log --all - вывести для всех достижимых коммитов
	git log <branch name 1>..<branch name 2> - Показать только те коммиты, которые были сделаны после расхождения веток
	git log <branch name 1>...<branch name 2> - Показать различающиеся коммиты для двух веток
	
6.4 Просмотр – Вывод git log коммитов, меняющих нужный файл

	git log -p <filename> - конкретные изменения файла
	git log --follow <filename> - если файл был переименован
	git log <commit name 1>..<commit name 2> -- <filename> - коммиты, которые идут после разветвления и в которых менялся указанный файл
	
6.5 Просмотр – Поиск в истории, фильтры для git log

	git log --grep <prompt 1> --grep <prompt 2> ... --grep <prompt n>
	
6.6 Просмотр – Кто написал эту строку? git blame

	 git blame <prompt> <additional flags> - найти того, кто написал конкретную строчку
	 
7.1 Слияние – "Истинное" слияние и разрешение конфликтов в git merge

	git merge <branch name> - переместить текущий указатель ветки на тот же коммит, что указывает указанный коммит
	При этом если у текущей ветки и указанной ветки есть различные (не общие) коммиты, то эти коммиты при merge будут забыты.
	Истинное слияние позволяет создать новый коммит, построчно сравнив каждое изменение в обоих ветках.
	git merge-base <branch name 1> <branch name 2> - показать где эти ветки разветвились
	Если при вызове git merge в файле(-ах) есть разные изменения для одного участка кода, то произойдет кофликт. Операция merge будет поставлена на паузу
	пока разрабочик вручную не укажет, какие изменения стоит вносить в новый коммит.
	
	git diff -U0 <branch name 1> <branch name 2> <filename> - показать изменения для указанного файла. Обычно в <branch name 1> можно указать коммит, с которого
	начинается разветвление, а в <branch name 2> одну из веток с которой происходит слияние.
	
	git checkout --ours / --theirs - вытащить файл, который хотим закомиттить в новый коммит
	git reset --hard - Прекратить слияние и очистить все изменения, откатившись до последнего коммита
	git reset --merge - Оставляет незакоммиченные изменения в файлах, которые не учавствовали в слиянии
	git megre --abort - то же самое, что и команда выше
	
	git show :n:<filename> - показать версию файла в разных источниках слияния:
		1 - общий предок (место ветвления)
		2 - ours - текущая ветка
		3 - theirs - ветка, с которой происходит слияние
		
	После того, как все конфликты будут решены:
	git merge --continue - создаст новый коммит слияния
	
7.2 Слияние – Коммит слияния, дальнейшие слияния

	git show <name of commit of merge> - в сообщении для коммита, созданого результатом слияния, будут указаны источники слияния + др.подробности
	в том числе diff секция, которая показывает изменения в конфликтом файле
	
	git diff HEAD^n - изменения, по сравнению с n родителем (1 / 2)
	git diff HEAD^^n - изменения, по сравнению с родителем n родителя
	git diff HEAD^n^m - изменения, по сравнению с m родителем n родителя
	
	git branch --merged - ветки, объединенные с текущей
	git branch --no-merged - ветки, не объединенные с текущей
	
	После слияния меняется общий предок (коммит ветвления)
	
7.3 Слияние – Отмена слияния

	git reset --hard @~ - перенести указатель ветки на предыдущий коммит. При этом коммит слияния становаться недостижимым.
	git merge <branch name> --log - флаг log добавляет в описание коммита заголовки всех сливаемых коммитов из сливаемой ветки
	
	Чтобы отменить отмену слияния:
	git reflog -n - посмотреть n последних записей в reflog
	git reset --hard @{n} - перенести указатель ветки на коммит под номером n в reflog.
	
7.4 Слияние – Семантические конфликты и их разрешение

	Семантические конфликты - изменения конфликтуют по смыслу (например в разных коммитах одна и та же функция принимает разные аргументы)
	git merge --no-commit - выполнить слияние, однако остановиться перед созданием коммита слияния
	Теперь можно исправить конфликты в коде и добавить их в индекс
	git merge --continue - продолжить слияние
	git commit --no-edit - то же самое

7.5 Слияние – Полезный приём: сохранение веток с флагом --no-ff

	git merge --no-ff --no-edit <branch name> - запретить перемотку и выполнить слияние.
	Используется в случае, если можно обойтись перемоткой, однако предпологается ситация, что слияние необходимо будет вернуть.
	При использовании этой команды будет известно название коммита родителя, с которого происходило слияние.
	
7.6 Слияние – Создание коммита из ветки: merge --squash

	Если между двумя ветками подлежащими слиянию нет конфликтов (т.е. одна ветка это родитель для другой ветки):
	git merge --squash <branch name> - выполнить слияние, однако не указывать родителей. При этом будет создан обычный коммит, а не коммит слияния.
	Если между двумя ветками есть конфлик лучше не использовать флаг --squash. Если это произошло:
	git merge --reset
	Если требуется завершить слияние:
	Поправить конфликт (изменить код), после проиндексировать изменения git add <filename>, git commit - завершить слияние
	
8.1 Копирование коммитов – Копирование коммитов: cherry-pick

	git cherry-pick <branch name> - скопировать коммит на который указывает указанная ветка в текущую ветку
	git cherry-pick -x <branch name> - указать в описании коммита откуда он был скопирован
	git cherry-pick <branch name 1>..<branch name 2> - скопировать всю ветку из <branch name 2> в <branch name 1>
	Если из-за предыдущей комманды был вызван конфликт слияния:
		git cherry-pick --abort - отменить копирование
		git cherry-pick --continue - продолжить копирование после разрешения конфликта
		git cherry-pick --quit - оставить успешно скопированные коммиты, и отменить копирование для оставшихся коммитов
	git reset --hard <commit name> - отменить cherry-pick уже после его завершения
	git cherry-pick -n <commit name> - копирование без коммита, будет изменена только рабочая директория и индекс
	
9.1 Перемещение коммитов – Перебазирование вместо слияния: rebase

	git rebase <branch name> - перенести коммиты текущей ветки на указанную ветку
	Работает в 2 этапа:
		1) По очереди скопировать коммиты текущей ветки поверх указанной ветки (cherry-pick)
		2) Перенести указатель текущей ветки на последний скопированный коммит
	Если при копировании произошел конфликт:
		1) git rebase --abort - отказаться от перебазирования
		2) git rebase --quit - оставить только успешно скопированные коммиты (HEAD останется на последнем успешно скопированном
		коммите, но указатель текущей ветки перемещен не будет.
		3) git rebase --skip - пропустить конфликтный коммит и начать копировать следующий
		4) git rebase --continue - после исправления конфликта продолжить операцию перебазирования

9.2 Перемещение коммитов – Rebase и merge: сравнение подходов

	Merge - например, используется чтобы исправить ошибку для master ветки (т.е. перенести изменения из fix, которые исправят эту ошибку)
	Rebase - взять из ветки master новые изменения, внести их в свою ветку и продолжить работу
	
	Стоит опасаться, что при копировании коммитов их можно сломать. При слиянии будет поврежден только коммит слияния.
	Избежать это можно автоматизированными тестами.
	
	Итоги rebase:
		+ Упрощает историю
		- Только для приватных веток
		- Возможны ошибки в коммитах
	
9.3 Перемещение коммитов – Rebase с тестами, флаг -x

	git rebase -x <command> <branch name> - выполнить результат команды будет отличаться от 0, то будет вызвана ошибка.
	Обычно используется для запуска автоматизированных тестов.
	Команда будет запускаться после попытки копирования каждого коммита. Если rebase упадет, то можно будет сделать исправления
	и продолжить перебазирование git rebase --continue
	
9.4 Перемещение коммитов – Перенос части ветки, rebase --onto

	git rebase --onto <branch name 1> <branch name 2> - перебазировать коммиты в <branch name 1> начиная с <branch name 2>
	git rebase --onto <branch name 1> <branch name 2> <branch name 3> - вначале переключиться на <branch name 3>, затем перебазировать
	коммиты в <branch name 1> начиная с <branch name 2
	Стоит помнить, что при перебазировании происходит перемещение указателя ветки. В некоторых случаях лучше использовать cherry-pick.
	
9.5 Перемещение коммитов – Перебазирование слияний, --rebase-merges

	git rebase --rebase-merges <branch name> - при перебазировании не пропускает, а копирует коммиты слияния и пропускает коммиты родительской ветки этого слияния
	
9.6 Перемещение коммитов – Интерактивное перебазирование, rebase -i

	git rebase -i <branch name> - интерактивное перебазирование
	Будет открыто окно редактора, где можно будет указать действия с копируемыми коммитами.
	Список действий:
		p, pick - скопировать коммит
		r, reword - скопировать коммит с измененнным сообщением
		e, edit - скопировать, однако после остановить rebase для внесения измнений в этот коммит
		s, squash - слить выбранный коммит с предыдущим, объединив сообщения
		f, fixup - как squash, только отбросить сообщение выбранного коммита
		x, exec - добавить в список произвольную комманду
		d, drop - пропустить коммит
	
9.7 Перемещение коммитов – Исправляем коммит посередине ветки: autosquash

	Чтобы редактировать коммит в середине ветки (перед этим исправив ошибки в рабочей директории):
	git commit -a --fixup=@~ - коммитнуть изменения из рабочей директории с сообщением исправляемого коммита fixup! <commit message>
	
	git rebase -i --autosquash <commit name> - при перебазировании исправляемый коммит и исправленный коммит будут слиты в один
	
10.1 Отмена коммитов через revert – Обратные коммиты, revert

	git revert <commit name> - создать новый коммит, в котором будут изменения прямо противоположные указанному коммиту
	git revert <commit name 1>..<commit name 2> - для всех коммитов с <commit name 1> (не включительно) до <commit name 2> (включительно)
	создать противополжные копии этих коммитов.
	
10.2 Отмена коммитов через revert – Отмена слияния через revert

	git revert <commit name> - если коммит является коммитом слияния, будет вызвана ошибка
	git revert <commit name> -m n - для коммита слияния, отменить изменения при слиянии для родителя n
	
10.3 Отмена коммитов через revert – Повторное слияние с rebase

	git rebase --onto <branch name 1> <commit name> <branch name 2> - перебазировать в <branch name 1> из <branch name 2> начиная с <commit name> (не включительно)
	
	rerere - механизм git, разрешающий повторные конфликты
	git config rerere.enabled true - включить механизм rerere
	Далее запустить .sh скрипт, чтобы показать механизму уже решенные конфликты:
	/your/own/path/to/rerere-train.sh
	--all - показать все решенные конфликты
	
	При перебазировании, после того, как механизм rerere разрешит какие то конфликты, их нужно будет добавить в индекс и продолжить перебазирование.
	
